#! /bin/bash
# Script to print "some" lines of a file, like head or tail but, random start
#
# Usage: some [[-#] FILE]

# Helper functions
PROG=`basename "$0" | tr -d '\n'`

function info()  { echo `date +%c` ${PROG}\: info: "$@" 1>&2; }
function warn()  { echo `date +%c` ${PROG}\: warning: "$@" 1>&2; }
function error() { echo `date +%c` ${PROG}\: error: "$@" 1>&2; }
function debug() { [[ -v DEBUG ]] && echo `date +%c` ${PROG}\: debug: "$@" 1>&2 || true ; }
function die()   { echo `date +%c` ${PROG}\: fatal: "$@" 1>&2 && exit 1; }

function truncate() {
    # trunchate a FILE to MAXLINES

    local FILE=$1
    local MAXLINES=$2

    local TEMP=`mktemp`

    cp ${FILE} ${TEMP} && \
        tail -${MAXLINES} ${TEMP} > \
             ${FILE} && \
        rm ${TEMP}
}



function someFunc {
    # Functon to print "some" lines of a file, like head or tail but, random start
    #
    # ARGS:
    #
    #   $1 - "-#" or FILENAME if only one arg
    #   $2 - FILENAME if present

    set -e; set -u; set -o pipefail # be safe out there

    HOW_MANY=10 # Number of lines to print.  Default.
    FILE="/dev/stdin" # default
    SOMELOG=${HOME}/.somelog # log of queries in case you want to find that chunk again
    MAXLOG=10

    if [ "$#" -eq 0 ]; then
        :
    elif [ "$#" -eq 1 ]; then
        if [[ "$1" =~ -[0-9] ]]; then
            HOW_MANY=`echo "$1" | sed 's/^-//'`
        else
            FILE="$1"
        fi

    elif [ "$#" -eq 2 ]; then
        if [[ "$1" =~ -[0-9] ]]; then
            HOW_MANY=`echo "$1" | sed 's/^-//'`
        else
            echo "some: Usage: some [-# [FILE]]"
            return
        fi

        FILE="$2"
    fi
    # TODO add real getopt parsing
    # TODO add -m|middle option to select lines from the middle

    # Count the lines to bound display
    LINES=`wc -l $FILE | sed -e 's/ .*//'`
    # TODO Do something sensible for stdin here
    #      Either
    #         - Save /dev/stdin to a tmp file (up to a max?), count THAT and use as FILE
    #         - revert to head-like behavior (with a timeout?)  (since we have no idea how long stdin is)

    # pick a random starting line at least HOW_MANY back from the end
    FIRST=$((1 + RANDOM % (LINES - HOW_MANY + 1 )))
    FIRST=$((FIRST>LINES ? LINES : FIRST))

    LAST=$((FIRST + HOW_MANY - 1))
    LAST=$((LAST>LINES ? LINES : LAST))

    # log line numbers to allow re-extraction of randomly chosen lines
    info lines $FIRST to $LAST \(of $LINES\) of `readlink -f $FILE` |& tee /dev/stderr >> ${SOMELOG}

    # only keep MAXLOG lines of SOMELOG
    truncate $SOMELOG $MAXLOG

    # Let's see some lines !
    awk "NR >= $FIRST && NR <= $LAST" $FILE
}

someFunc $*
